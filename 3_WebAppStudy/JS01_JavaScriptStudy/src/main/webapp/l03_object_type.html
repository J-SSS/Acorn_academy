<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Object와 자료형</title>
</head>
<body>
  <h1>자바스크립트의 자료형들</h1>
  <p>자료형(참조형) 데이터 : 복수의 데이터를 참조하는 것을 의미(프로그래밍에서 객체를 의미)</p>

    <h2>자바스크립트의 object</h2>
  <ul>
      <li>Object : 모든 프로토타입의 부모타입(js는 프로토타입 언어임)</li>
      <li>프로토타입 언어 : 타입을 명시하면 프로토타입(생성자가 명시됨)이 생성되고 객체생성시 프로토타입을 참조(객체지향언와 크게다르지않음)</li>
      <li>new 연산자 : 프로토타입에 명시된 생성자를 호출해서 객체를 반환한다.</li>
      <li>new Object() =={} : 객체 생성을 리터럴하게 할 수 있다.</li>
      <li>js는 함수가 타입이 되기 때문에 함수를 명시하면 프로토타입이 생성된다(타입과 함수(실행의 모음)의 구분이 없다)</li>
      <li></li>
  </ul>

  <H2>객체지향 언어(타입이 명확한 언어) 자바와 프로토타입언어 자바스크립트의 공통점</H2   >
  <ul>
      <li>자바 : 다형형성, 추상화, 상속, 정보은닉, 캡슐화...</li>
      <li>모든 타입의 부모는 Object</li>
      <li>new  연산자로 생성자를 호출하면 객체를 반환</li>
      <li>기본형과 자료형을 구분한다(파이썬은 모두가 자료형임)</li>
      <li>힙메모리의 GC가 객체의 메모리 정리를 자동으로 한다</li>
      <li>캡슐화가 가능(es 6에서 추가)</li>
      <li>(X)둘 다 class가 존재한다??(js의 class는 물리적으로 존재하지 않는 sugar static임(lambda와 동일))</li>
  </ul>

  <h2>인터프리터 언어와 컴파일 언어의 차이</h2>
  <ul>
      <li>인터프리터 언어 (==스크립트언어)(js,python,ruby) : 문자열로 된 코드를 컴파일하면서 동시에 실행(문자열코드가 바로 배포됨) </li>
      <li>컴파일 언어(java,c,c++) : 문자열로 작성한 코드가 컴파일 과정을 거친 후 배포되는 언어(.java - > .class) </li>
      <li>컴파일 언어는 컴파일시 검출하는 오류를 배포하지 않음(안전함) </li>
      <li>스크립트언어는 오류가 있어도 배포 가능(안전X)</li>
      <li>컴파일 언어가 실행이 더 빠르다</li>
      <li>인터프리터 언어는 컴파일 과정이 없기에 구현이 빠르다</li>

  </ul>
    <h2>객체지향 언어와 프로토타입 언어(함수형언어)의 차이</h2>
  <ul>
      <li>객체향 언어인 자바는 class를 객체의 타입으로 사용한다 <->프로토타입언어는 프로토타입을 타입으로 사용</li>
      <li>객체지향 언어의 상속은 부모의 필드를 물려받고 재정의 할 수 있다 <-> 부모 프로토타입을 링크로 사용할 수 있다</li>
      <li>class는 오직 타입이다. <-> 프로토타입은 객체처럼 생성되어있다.</li>
      <li>함수가 타입일 수 없다 <-> (매개변수로 함수를 사용할 수 있고 함수를 변수가 참조할수도 있다)</li>
  </ul>

  <h2>js에서 타입을 명시하고 객체를 생성하는 방법</h2>
  <ul>
      <li>함수를 정의하면 프로토타입이 생성됨(함수명은 파스칼규칙 : 개발자간의 약속)</li>
      <li>필드는 this로 선언 (this : 해당 함수가 객체가 되었을 때 필듸 접근자!! ***)</li>
      <li>함수의 이름과 매개변수가 생성자로 작성됨</li>
      <li>new 연산자로 함수를 호출하면 생성자가 반환됨</li>
      <li>주의 : 반환값을 작성해도 동작하지 않는다.. new 없으면 일반 함수처럼 호출되긴 함</li>
  </ul>

  <h2>js에서 타입 명시 없이 객체를 생성하는 방법 1</h2>
  <ol>
      <li>const o = new Object</li>
      <li>o.property(==필드,속성,재산) = value(기본값, 자료형, 함수 모두가능)</li>
  </ol>

  <h2>js에서 타입 명시 없이 객체를 생성하는 방법 2</h2>
  <ol>
      <li>const o = {}; (== new Object}</li>
      <li>{property : value,  "property" : value}</li>
      <li>property는 중복될 수 없다.(Set과 유사함)</li>
      <li>key는 변수명, 문자열, 수, symbol로 작성할 수 있다. (1:"" 필드명을 수로 작성하면 오름차순 정렬됨)  </li>
      <li>JSON : Object 명세서를 객체선언에 바로 사용하는 경우(Object를 리터럴하게 선언한다)</li>
      <li>일반적으로 사용되는 JSON은 이 명세서가 보기 좋고 메모리 절약을 하고 통신 속도가 빨라서 문자열로 사용되는 것을 말함</li>
      <li>예) person {name : "경민" } => person.json "{\"name\":\"경민\"}" (문서)</li>
      <li>객체 정보를 통신으로 전달할 때, json 등장 전에는 xml을 통신에 사용</li>
      <li>
          <xmp>
          <personList>
              <person>
                  <name>경민</name>
              </person>
              <person>
                  <name>경민</name>
              </person>
              <person>
                  <name>경민</name>
              </person>
          </personList>

          ==

          personList.json [{name : 경민}, {"name" : "은정"}, {"name" : "재연"}

          </xmp>
      </li>
      <li>통신 속도와 비용은 통신하는 문서의 크기에 비례하면서 증가한다.(xml이 더 느리고 비용도 더 든다)</li>
      <li>xml은 문서고(binaryCode) json은 오직 문자열(Text)로만 되어있어서 변환과정이 없다(해석이 빠름)</li>
      <li>html 통신시 json으로 통신하면 object로 변환 가능하고 xml은 document로 사용해야한다(java에는 JackSon -> 자바객체로 변환)
          <ul>
              <li>JSON : const ps = JSON.parse(personList); ps[1].name -> "은정"</li>
              <li>XML : const ps = personList.xml; ps.getElementsByTagName("person")[1].getElementsByTagName("name")[0].textNode -> "은정"
              (dom tree 검색 : dom travleing)
              </li>
          </ul></li>
        <li>xml이 key와 value를 더 안전하게 전달한다 (마크업 언어가 문자열보다 안전하다!!
            예) {"name : 경민", age : 38 } : json은 파싱에 오류가 발생가능</li>
      <li>xml의 value는 무조건 text이고 json의 value는 기본형을 구분할 수 있다</li>
      <ul>
          <li>
              <xmp>
                  <age>38</age> -> "38"
              </xmp>
          </li>
          <li>{age : 38} -> 38 (number or int)</li>
          <li>
              <xmp>
                  <married>true</married> -> "true"
              </xmp>
          </li>
          <li>
              {married : true} -> (boolean) true
          </li>
          <li>JSON을 명시할 때 기본형 규칙대로 리터럴하게 선언하면 객체형 변환시 기본형으로 파싱된다.
              (symbol 제외)(타입을 명시할 수 있다)</li>
          <li>xml은 value가 무조건 text기때문에 다른 기본형으로 사용하고 싶다면 형 변환을 해야한다
              (타입을 명시할 수 없다)
          </li>
          <li>JSON 사용시 주의할 점 : undefined와 함수를 작성하면 안됨(undefined가 없는 언어가 존재)
          (함수를 전달하면 함수를 실행하면서 해킹을 할 수 있다)
          </li>
      </ul>
  </ol>

  <h2>객체의 필드를 호출하는 방법</h2>
  <ul>
      <li>let pName = person.name; :호출</li>
      <li>let pName = person["name"]; : 필드를 문자열로 호출</li>
      <li>let age = person.10; : 오류(숫자로 된 필드는 무조건 대괄호로 호출</li>
      <li>let age = person[10]; (0)</li>
      <li>** 자바는 수로 된 필드를 정의할 수 없다! (거의 대부분 언어가 못하는거긴 함..JS만 가능)</li>
      <li>옵셔널체이닝(Optional Channing) : personList[3].person.name (null.name 실행시 발생하는 오류) </li>
      <li>옵셔널체이닝(Optional Channing) : personList[3].person?.name ( if(person!=null) person.name을 의미) </li>
      <li>"property" in 객체 : 객체에 필드가 있는지 검사하는 연산자 in</li>
      <li>for(let propertyName in 객체) {} : 객체에 존재하는 필드 수만큼 반복문 실행</li>
      <li>for(let propertyName in 객체){객체.propertyName;} : (X)오류..(문자열로 된 필드는 무조건 대괄호로 호출)</li>
      <li>for(let propertyName in 객체){객체[propertyName];} : (문자열로 된 필드는 무조건 대괄호로 호출)</li>

  </ul>
<script>

    function Person(name, age){ //타입으로 사용될 함수는 파스칼 규칙을 사용
        this.name = name; //this : 객체의 필드 접근자(js는 필드 정의 할 때도 사용됨)
        this.age = age;
        //type는 new 연산자 호출시 객체를 반환하록 이미 명시되어있어서 return을 작성할 수 없다.

    }
    function sum(a,b) { //연산의 집합으로 사용되는 함수는 낙타표기법을 사용
        return a+b;

    }

    console.log(Person) //코드가 출력됨
    console.log(Person.prototype) //함수를 명시하면 프로토타입을 생성한다.
    const p = new Person("동일",33) // person.prototype를 기반으로 객체를 생성

    console.log(p)
    console.log(p.__proto__) //객체의 타입(__proto__ : 객체의 부모 프로토타입을 찾는 링크)
    console.log(p.__proto__.__proto__) //객체의 타입의 부모타입 (object의 프로토타입)
    console.log(p.__proto__.__proto__.__proto__) //object의 부모타입은 없다

    console.log(sum)
    console.log(sum.prototype)
    console.log(sum(1,5))

    let a =2;
    let b =2;
    let c =4;
    console.log(++a ** a++);

    //Persoon과 같은 객체를 타입 없이 만들어보기

    const person = new Object(); //자료형을 참조할때는 상수로 작성한다(타입이 명확하지 않아서~?)
    person.name = "장동일"; //객체에 필드를 정의하는 방법
    person.age = "33";
    console.log(person) // {name : '장동일' , age : 33}

    // {name : '장동일' , age : 33} : 자바스크립트의 오브젝트 명세서 JavaScript Object Notation (Json)
    // JSON : Object를 설명하기 위한 표기법 (리터럴하게 오브젝트를 명시한다)

    const person2 = {name : "최경민", age : 38, name : "경민"}; //
    // {} == new Object
    // name : "최경민" == person2.name = "최경민"
    console.log(person2)

    console.log("name" in person2); //필드를 검사하는 연산자 name이라는 필드가 있는지를 boolan

</script>
</body>
</html>