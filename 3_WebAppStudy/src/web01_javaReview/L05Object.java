package web01_javaReview;

public class L05Object {

//
//    public L05Object() {
//    }
//
//    public L05Object(int a, Object o){
//        //생성자 : 함수와 비슷하지만 클래스명으로 작성함
//        this.a = a;
//        this.o = o;
//    }


    int a ; // this.a로 접근할 수 있는 해당 객체의 필드다.
    public void print(){}; //this.print로 접근할 수 있는 해당 객체의 필드다.
    //this는 필드 접근자인데 클래스가 객체로 생성됨을 가정하여 작동함.

    static int b; // L05Object.b 이런식으로 접근해야함. 정적멤버는 class의 이름만 빌려옴

    //변수 : 데이터(기본형+자료형)을 할당or참조하는 것
    //상수 : 최초에 참조한 데이터가 바뀌지 않는 것
    //지역변수 : 전역이 아닌 스코프에(메소드, 제어문, 반복문과 같은 블럭{}) 존재하는 변수(해당 블럭 내에서만 참조가능한 변수)
    //전역변수 : 해당타입이 객체가 되었을 때 재원이 되는 것
    //매개변수 : 생성자나 메소드를 실행할 때 제공하는 데이터



    //메모리 영역
    //힙 : 인스턴스 객체가 생성되는 곳(java가 유명하게 된 이유) : 가비지 컬렉션이 사용하지 않는 객체를 자동으로 치운다.
    //스택 : 작업에(=main 실행에 필요한 코드) 필요한 메모리 공간으로(메소드단위)
    // 스택메모리 구조를 갖고, main에서 실행할 변수와 메소드 연산을 스케쥴링해서 참조
    //메소드 : jvm이 실행되면서 사용되는 class를 분석해서 메소드영역에 저장하는데, 이때 static으로 선언된 정적멤버를 같이 생성한다.


    //static과 정적멤버(클래스변수.. 클래스명.변수이름 으로 호출할수있으니까)
    //최초에 메소드영역에 생성되기 때문에 객체 생성 없이 참조 가능하고 자동 삭제되지 않고 남는다.
    //주의 : 너무 많이 선언하면 안된다...초기화를 하지 않기 때문에, 기대했던 값이 아닐수있다???(상수로 선언되는 편...)
    public static void main(String[] args) { //L05Object의 필드가 아니기 때문에 this를 사용할 수 없다.

        System.out.println(b); //정적 멤버끼리는 아무렇게나 호출 가능

        //class = 자료형타입, 객체의 타입, 타입...(기본형type은 class가 아니다!)
        //필드(Field), 속성(Attribute), 멤버 // 전체영역에 선언된 것들.. static(정적멤버)은 제외
        //객체, 오브젝트(object), 데이터(잘 사용하지 않음), 인스턴스 // new 연산자로 생성자를 호출할때 반환하는 것
        //this : 필드접근자 (해당 클래스가 객체가 되었을 때 사용됨)
        //class Object : 개발자가 타입을 명시하고 객체를 생성할 수 있도록 하는 최초의 설계도. 모든 타입의 부모. 조상..

        //메소드 : 재사용할 실행의 집합으로, 매개변수에 의해 실행을 제어하고 결과를 반환할 수 있다.
        //생성자 : 객체 생성시 호출되는 생성자는 매개변수 필드를 초기화(첫 세팅)할 수 있다.
        //= 객체를 생성할 때 호출하여 필드를 초기화함. new연산자가 객체를 생성. 생성자가 이미 빈환하는 타입을 의미하기 때문에 반환겂은 쓰지않음
        //
        



    }
}
