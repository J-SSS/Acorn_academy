<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Spring board</title>
</head>
<body>
    <header th:include="headerNav.html"></header>
    <main class="container">
        <h1 class="my-4">Spring Boot(+Mybatis)로 댓글 게시판 만들기</h1>
        <h2>maven vs gradle</h2>

        <h2>객체지향(OOP)vs 관점지향 언어(Aspect-Oriented Programing)</h2>
        <ul>
            <li>객체지향 언어 : 필요할 때 객체를 생성 및 사용</li>
            <li>관점지향 언어 : 사용할 객체를 관리(contaier or factory)만 하다가 필요한 곳에 주입(DI)</li>
                관리만 하는게 컨테이너, 생성까지 해주면 팩토리
            <li>객체지향 언어의 장점 : 코드 작성이 쉽고 흐름이 보인다.</li>
            <li>관점지향 언어의 장점1 : 객체를 필요할 때 마다 생성하지 않기 때문에 메모리절약(서버환경에 유리)</li>
            <li>관점지향 언어의 장점2 : 공통 관점으로 코드를 분리해서 중복 코드를 줄인다 (생산성 up, 유지보수 up)</li>
            <li>관점지향 언어의 장점2 : 객체를 생성하는 코드가 없기 때문에 기능을 동적으로 추가하는 것이 유리하다</li>

            <li>객체지향 언어의 단점 : 객체를 무분별하게 생성할 가능성이 높다</li>

            <li>관점지향 언어의 단점 : 구현이 어렵고 흐름이 보이지 않는다..spring이 어려운 이유</li>
            <li>관점지향 언어의 단점 : 관점지향을 구현하는 프레임워크에 의존적이다 </li>
            <li></li>
        </ul>
        <h2>스프링과 관점지향 언어와 MVC 패턴</h2>
        <ul>
            <li>자바로 관점지향을 구현했기 때문에 객체지향 언어의 장점을 포함한다</li>
            <li>스프링 컨테이너가 객체(@Component)를 관리하고 있다가 @Autowired로 정의된 필드에 주입(생성자) </li>
            <li>객체를 주입 : Depencency Injection (DI)</li>
            <li>@Controller : spring - web에서 관리하는 객체로 http 통신의 요청과 응답을 처리</li>
            <li>@Service(Model) : db접속의 트랜잭션을 관리 </li>
            <li>thymeleaf(템플릿 엔진) : src/resources/templates 하위의 html을 view로 렌더링 </li>
        </ul>
        <h2>spring-mybatis</h2>
        <ul>
            <li>mybatis : xml로 작성된 sql을 java객채로 맵핑</li>
            <li>spring-mybatis : spring에서 mybatis를 사용할 수 있도록 최적화되어있고</li>
                sql(session)을 객체로 생성 관리하는 컨테이너(session factiory)를 제공함
            <li>Mapper 인터페이스 작성(@Mapper) : mybatis는 @Mapeer가 정의된 인터페이스를 Mapper.xml에 정의된 sql로 컴포넌트를 생성함</li>
            <li>Mapper xm : sql(Session)을 관리하고 테이블의 관계의 관계를 정의해서 조인을 할 수 있다.</li>
            <li>** 사용할 곳에서 의존성 주입(DependencyInjection) 받기 : session factory가 @Mapper로 정의된 인터페이스를 객체로 만들어서 주입 </li>
        </ul>
        <h3>Sptring Mybatis 설정</h3>
        <ol>
            <li>DataSource : resource>application.propertie(yml) applicaton.properties에 mybatis:mapper-location 작성</li>
            <li>인텔리제이의 MybatisX플러그인 설치</li>
            <li>@Mapper 인터페이스 생성 및 추상메서드 정의</li>
            <li>인터페이스에서 마우스 오른쪽 클릭 > Show Context Action > [MybatisX] GenerateMybatis xml 클릭 후
            mapper-location에 지정한 폴더에 xml 생성됨</li>
            <li></li>
        </ol>
        <h3>Mapper.xml 정의 방법</h3>
        <ul>
            <li>mapper namespace="@Mapper의 타입" : 컴포넌트(컨테이너에서 관리되는 객체)로 생성할 타입</li>
            <li>id="추상메서드 이름" : 쿼리가 실행될 메서드 정의</li>
            <li>select : DQL 작성할 때 사용하는 태그 : **resultType or resultMap을 작성해야한다
                <ul>
                    <li>select는 무조건 resultType으로 정의된 객체나 java.utril.List를 반환</li>
                    <li>만약 추상메서드에서 객체만 반환한다고 정의했는데 복수가 반환되면 오류가 발생한다</li>
                    <li>resultType으로 정의된 DTO필드와 반환되는 테이블의 칼럼과 동일한 이름이 있다면 맵핑에서 반환</li>
                    <li>만약 칼럼과 필드명이 다르면 as로 필드와 같은 이름을 만들거나 resultMap을 정의해야한다
                        대부분의 db는 대소문자를 구분하지 않더라.. 이름규칙으로 _를 사용, 자바는 카멜표기법을 사용해서..</li>
                    <li>만약 반환되는 타입을 resultMap을 사용한다면 association, collection으로 정의된 필드는 한번 더 조회한다(조인처럼 동작함)</li>
                </ul></li>
            <li>delete, update, insert : DML을 작성할 때 사용하고 몇개 성공했음의 정수(int,long)를 반환</li>
            <li>mybatis와 매개변수(PreparedStatement) : Dto의 필드명이나 변수명을 #{}을 작성하면 매개변수로 동작한다</li>
            <li>만약 필드명이나 변수명을 사용하고 싶지 않다면 @Param(value="바꿀이름")을 작성하면 된다.</li>
            <li>order my에서 필드명을 매개변수로 받아야한다면 ${}에 작성하면 된다. order by #{filed} => order by 'b_id'는 동작 x</li>
        </ul>
        <h3>resultMap</h3>
        <p>질의(DQL)의 결과를 자바객체(POJO,DTO)에 맵핑하는 역할과 객체간의 연관성을 포함</p>
        <ul>
            <li>객체의 필드와 칼럼 맵핑</li>
            <li>복합, 객체 맵핑 : Dto에 존재하는 복수의 필드를 관계로 맵핑</li>
            <li>상속관계맵핑 : DTO의 부모타입으로 맵핑됨</li>
            <li>컬렉션 맵핑 : 해당 테이블과 참조 관계에 있는 다른 테이블의 복수의 값을 조회해서 맵핑 가능</li>
            <li>collection(List(default),Map,Set)association(dto) : 해당 테이블과 참조 관계에 있는 다른 테이블을 조회</li>
            <li>property : 조회해서 맵핑할 필드</li>
            <li>select : 조회할 session(sql) id </li>
            <li>column : 조회할 sql 파라미터로 제공할 칼럼</li>
            <li>fetchType : [eager , lazy ] 조회할 방식으로 즉시로딩과 지연로딩 설정할 수 있다</li>
            <li>지연로딩 : collection, association에 정의한 필드를 view에서 호출하면 조회함</li>
            <li>즉시로딩 : 호출이 있지 않아도 조회</li>
        </ul>
    </main>


</body>
</html>
