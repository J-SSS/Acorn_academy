<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>기본형 데이터의 타입</title>
</head>
<body>
    <h1>자바스크립트의 기본형 데이터와 타입</h1>
    <h2>JAVA에서의 기본형</h2>
    <ul>
        <li>byte</li>
        <li>short</li>
        <li>int</li>
        <li>long</li>
        <li>float</li>
        <li>double</li>
        <li>boolean</li>
        <li>char </li>
    </ul>

    <h2>JS의 기본형</h2>
    <ul>
        <li>number : 자바의 double과 같으며 NaN, Infinity가 추가됨</li>
        <li>bigInt : number타입이 가장 정확하게 표현할 수 있는 정수보다 큰 수를 표기할 때 사용</li>
        <li>String : 자바의 char[]과 같은 타입으로 자바String과는 다르다.("",'',`${변수}`)
            <br>
            (자바에서 참조형인 문자열을 기본형으로 사용중인 이유와 유사함)
            <br>
            (String과 다르며 배열은 자료형인데 기본형으로 사용중 뭔소리?)</li>
        <li>boolean : 논리 연산의 결과로 true, false를 나타낸다</li>
        <li>null : 자료가 없다. 수로 형변환하면 0으로 취급</li>
        <li>undefined : 선언되지 않음. 선언되지 않은 상태의 변수를 참조할 때 발생하는 오류를 예방하기 위해 존재(NaN)</li>
        <li>symbol : 고유값을 반환하는 기본값으로 Iterable한 자료의 식별자를 정의할 때 사용됨</li>
    </ul>
    <p>typeof : 기본형의 타입을 문자열로 반환하는 연산으로, 자료형인경우 object로 반환하고 함수는 "function"으로 반환</p>



    <h2>number 기본형</h2>
    <ul>
        <li>정수 : 정수를 선언해도 실수가 된다.</li>
        <li>실수 : 8byte짜리 실수로 java의 double과 똑같다.</li>
        <li>NaN : Not a Number의 준말로 특정 데이터를 수로 변환할 수 없는 데이터를 수로 변환할때 오류를 발생하지 않으려고 등장</li>
        <li>Infinity : 무한대</li>
    </ul>

    <h2>string 문자열</h2>
    <ul>
        <li>"",'',``으로 선언가능</li>
        <li>메모리에 케릭터 배열의 형태로 저장되어 자료형이지만 자바스크립트에서는 기본형으로 취급한다</li>
        <li>+(concat()) 더하기 연산이 가능</li>
        <li>자바처럼 리터럴하게 선언하면 새로운 문자열을 만들지않고 기존의 문자열을 참조</li>
    </ul>

    <h2>수 연산자</h2>
    <p>*, /, %, **, +, =, ++, --, +=, -=, *=, /=, %=</p>
    <ul>
        <li>+ : 더하기 연산은 수와 문자열 둘 다 연산할 수 있다.
            <br>문자열의 + 연산은 String.concat()을 하는 것과 같다.
            <br>예) "a"+"b" == String.concat("a","b")
        </li>
        <li>문자열과 수를 + 연산했을 때 수를 문자열로 취급한다.
            <br> + 연산을 제외한 모든 연산은 문자열을 수로 변환한다
            <br>문자열의 자동형변환시 문자열이 수가 될 수 없으면 NaN가 반환된다(java의 NumberFormatException 오류)
        </li>
        <li></li>
        <li></li>
        <li></li>
    </ul>

    <h2>비교연산자</h2>
    <p>(이항 : ==, !==, >=, <=, ===), (단항 : !),(js는 자료형을 비교하는 <object.equals()가 없다.)</p>
    <ul>
        <li> 1==1 :
            <script>document.write(1==1)
            </script>
        </li>
        <li> 1=="1" :
            <script>document.write(1=="1")
            </script>
        </li>
        <li> 1==="1" :
            <script>document.write(1==="1")
            </script>
            (===는 형변환 없이 비교연산, 완전동등비교연산)
        </li>
        <li> "13">=1 :
            <script>document.write("13">=1)
            </script>
            (13>=1)
        </li>
        <li> "십삼">=1 :
            <script>document.write("십삼">=1)
            </script>
            (NaN>=1)
        </li>
        <li> "십삼"=="십삼" :
            <script>document.write("십삼"=="십삼")
            </script>
        </li>
        <li> "십삼"==="십삼" :
            <script>document.write("십삼"==="십삼")
            </script>
        </li>
        <li> "십삼"== new String("십삼") :
            <script>document.write("십삼"==new String("십삼"))
            </script>
            (new String("십삼") => "십삼"의 기본값만 참조 후 비교연산)
        </li>
        <li> "십삼"=== new String("십삼") :
            <script>document.write("십삼"===new String("십삼"))
            </script>
            (기본형과 자료형을 동등비교했기 때문에 false)
            (java에서는 다른 이유로 false..)
            (java는 둘 다 자료형이기 때문에 ==으로 비교연산 할 수 없다.)
            (java는 String은 리터럴하게 선언하면 같은 값을 참조하기 때문)
        </li>
        <li> 리터럴한 선언법 : 보이는 그대로가 데이터가 된다
        <br> (대부분의 프로그래밍 언어에서 기뵨형데이터는 리터럴하게 선언됨)
        <br> (1)  : new Person("경민",37) : 어떤 data로 구성되었는지 파악불가
        <br> (2)  {name : "경민", age = 37, work : function(){}, talk:()=>{}}

        </li>
    </ul>

    <h2>기본형과 랩퍼클래스와 자동완성!</h2>
    <ul>
        <li>랩퍼클래스 Number, BigInt, String, Boolean 기본데이터 타입을 도와주는 필드의 짖ㅂ합</li>
        <li>기본형에서 바로 랩퍼클래스의 필드에 접근하는 것 처럼 사용가능하다(자동완성)</li>
        <li>문자열도 char[]의 형태로 메모리에 저장되어있기때문에 랩퍼클래스 string에서 필드를 호출한다</li>
        <li></li>
    </ul>
    <h2>Number 랩퍼클래스의 유용한 함수들</h2>
    <ul>
        <li>isNaN("문자") : 매개변수가 수로 형변환 불가능한지(불가능 :true , 가능 :false)</li>
        <li>Number.isNaN(NaN) : 매개변수가 NaN인지만 확인 (NaN : true)</li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
    <h2>Math의 유용한 함수들 찾아보기</h2>
    <h2>String의 랩퍼클래스의 유용한 함수들 찾아보기</h2>

<script>

    let num = 13.33;
    console.log(num + " : " + typeof num) // typeof는 타입을 문자열로 반환
    num = 13;
    console.log(num + " : " + typeof num)
    num=Number("십삼"); //문자열을 수로 형변환
    console.log((13-"일") + " : " + typeof num) //NaN : 수와 관련된 오류를 표시
    console.log((1/0) + " : " + typeof num)

    let bigInt = 123123123123123123123123123123123123123123123123;
    console.log(bigInt); // numberd타입의 부동소수 점으로 출력됨
    console.log(bigInt + " : " + typeof bigInt)
    bigInt = 123123123123123123123123123123123123123123123123n; // n을 붙이면 큰 정수가 됨
    console.log(bigInt) // 작성한대로 출력됨
    console.log(bigInt + " : " + typeof bigInt) // bigint타입으로 출력

    let string = "안녕";
    console.log(string + " : " + typeof string); // char[] = {'안','녕'}
    string = new String("안녕");
    console.log(string + " : " + typeof string); // String s = "안녕" or new String("안녕")
    string = '안녕~'; //js는  ""랑 '' 을 똑같이 문자열로 봄
    // 둘의 차이는?? 기본데이터타입의 배열을 기본형으로 볼건지의 문제
    /*
        배열을 자료형으로 보는게 맞나??
     */
    let name = '동일';
    string = `안녕하세요! ${name}씨~`; // `` 백틱으로 선언하는 문자열은 표현식으로 + 연산을 대신할 수 있다
    console.log(string + " : " + typeof string);

    //기본형의 랩퍼 클래스와 자동완성!
    //기본형에는 필드가 없지만 마치 자료형인 것 처럼 사용가능하다

    let i = 1000.1234;
    console.log("i.toFixed()i : " + i.toFixed(4)) //기본형에는 필드가 존재하지 않지만 있는 것 처럼 쓸수있음
    //new Number(i).toFixed가 원래모습임
    //js는 자동형변환에 자동완성이 이해를 더욱 어렵게할수있음 . 그대신 이해하면 코드가 줄고 생산성이 높아진다

    //js의 자동 형변환이 이해를 더욱 어렵게 할 수 있다 => 이해하면 능률적이다

    console.log(`0.1+0.2 = ${0.1+0.2}`)

    //NaN
    let input = "십"; //숫자이길 기대해
    console.log(`Nan==NaN : ${NaN==NaN}`)
    console.log(`Number.parseInt("십")==NaN : ${Number.parseInt(input)}`);
    console.log(`isNaN("십") : ${isNaN(input)}`);//"십"이 숫자로 형변환 불가한가?
    console.log(`Number.isNaN("십") : ${Number.isNaN(input)}`);//data가 NaN인지만 확인
    console.log(`Number.isNaN(parseInt("십")) : ${Number.isNaN(parseInt(input))}`);


    //자바스크립트는 문자를 수와 연산 할 때 수로 형변환한다
    console.log("1"+1); // => 11 (그러나, 더하기연산은 수를 문자열로 만들어서 형변환한다. +에서는 문자열이 우선임)
    console.log("1"-1); // 1-1 => 0 (-,*,/,%,** 는 문자열로 연산 불가하기때문에 수로 형변환한다)

    console.log("일"-1); //이 경우엔 수로 형변환하므로 NaN발생하나
    console.log("일"+1); // 더하기 연산에서는 문자열로 변환하므로 '일1'이 됨



</script>


</body>
</html>