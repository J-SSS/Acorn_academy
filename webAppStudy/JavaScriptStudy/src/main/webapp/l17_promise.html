<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>비동기 실행을 동기화 하기</title>
</head>
<body>
    <h1>멀티 스레드간의 비동기된 상태를 동기화 하는 방법</h1>
    <h2>
      <button id="testBtn">알람!</button>
      경고창 3초 뒤에 뜨고 2초 뒤에 경고창 뜨게 하려면...</h2>
    <p>
      코드를 연이어 작성해서 동기된 동작을 기대하지만 setTimeout()은 thread를 생성하기 때문에
        비동기된 동작을 보이면서 2초 뒤 경고가 먼저 뜨게된다.
    </p>
  <script>
    testBtn.onclick=function (e){
      window.setTimeout(()=>{alert("화면이 열리고 3초 뒤 경고!!")},3000)
      window.setTimeout(()=>{alert("2초 뒤 다시 경고!!!!")},2000)
    }
  </script>
    <h2><button id="testBtn2"></button>
    콜백 지옥으로 비동기 코드를 동기화하기!</h2>
    <p>멀티스레드인 코드의 특정 시점을 동기화하고 싶다면 그 코드가 종료되는 시점에서 다시 함수 호출하는 형식으로
    동기화 할 수 있다.
    이런 현상이 계속 반복되면 중첩으로 코드가 복잡해져서 콜백지옥이라부른다.
    </p>
    <p>자바스크립트의 대부분이 멀티스레드로 동작하는데 동기화를 위해서 콜백지옥을 만들게된다
    타이밍함수, ajax, 이벤트리스너등등....모두 멀티스레드로 동작함</p>
<script>
    testBtn2.onclick=function (e){
        window.setTimeout(()=>{
            alert("화면이 열리고 3초 뒤 경고!!")
                window.setTimeout(()=>{
                    alert("2초 뒤 다시 경고!!!!")
                },2000)
        },3000)
    }
</script>
    <style>
        #circleBox{
          border-radius: 50%;
            width: 0px;
            height: 0px;
            background-color: red;
            /*animation: moveBox 2s forwards;*/
            margin-left: 0;
        }
        /*@keyframes moveBox {*/
        /*    50%{*/
        /*        width: 200px; height: 200px;*/
        /*        margin-left: 0;*/
        /*    }*/
        /*    100%{*/
        /*        margin-left: calc(100% - 200px) ;*/
        /*    }*/
        /*}*/
    </style>
    <h3>0~200까지 커지는 원을 만들고, 오른쪽 끝으로 이동</h3>
    <div>
        <p id="circleBox"></p>
    </div>

    <script>
        /*
        브라우저에서 애니메이션 작성법 :
        1.transition(복잡한거 불가)
        2. animation
        3. 자바스크립트 setInterval
         */
        let w = 0;
        const circleBox = document.getElementById("circleBox")
        let cBox = setInterval((e)=>{
          circleBox.style.width=(++w)+"px"
          circleBox.style.height=(++w)+"px"
            if(w==200){
                clearInterval(cBox)
                setInterval(()=>{
                    circleBox.style.marginLeft=200+"px"
                },10)
            }
        },10)
        // let leftEnd = circleBox.parentElement.clientWidth
        // let left = 0;
        // let cMove = setInterval(()=>{
        //     circleBox.style.marginLeft=(++left)+"px"
        //     if(leftEnd==left)clearInterval(cMove)
        // })


    </script>
    //오른쪽 끝으로 이동하는 interval을 만들어보세요~
    //크기가 200일때 오른쪽으로 이동하는~

    <h2>멀티스레드간의 동기화를 위한 콜백지옥 탈출을 위해 등장한 영웅!? promise</h2>
    <p>콜백지옥만 탈출하지 코드는 더 어려워진다... 진정한 구원자 async함수가 등장한다!!</p>
    <h3><button id="testBtn3">알람!!</button> 3초 뒤 알람이 뜨고 2초 뒤 알람!!</h3>
<script>
    testBtn3.onclick=function (e) {
        const p = new Promise((resolve)=>{
            setTimeout(()=>{
                alert("3초 뒤 알람!");
                resolve("알람성공!!")
                //동기화 하고 싶은 시점에서 resolve 함수를 실행하면 .then에 오는 첫번째 콜백함수가 동기화되어 실행됨
                //만약 오류가 발생하거나 동기화하면안될때는 reject함수를 실행하면 .then 에 오는 두 번째 콜백함수가 실행됨
            },3000)
        }).then((resolveMsg)=>{
            setTimeout(()=>{
                alert(resolveMsg+"2초 뒤 알람")
            },2000)

        })
    }

    //Promise는 완벽한 동기화를 하기에는 부족함이 있고 코드가 복잡해지는 경향
    //reject finally, error 같은 추가 기능은 깊이있게 안함
</script>
</body>
</html>