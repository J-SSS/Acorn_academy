<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>자바스크립트의 함수</title>
</head>
<body>
    <h1>연산의 집합 함수(method)</h1>

    <h2>함수 선언과 사용법</h2>
    <ul>
        <li>function 이름(매개변수) {return 반환값;} : 작성법</li>
        <li>이름(매개변수); : 호출법 (아무것도 안쓰면 undefined가 매개변수로 넘어감)</li>
        <li>return; : 을 작성하면 다음 코드가 있어도 함수를 종료한다.</li>
        <li>매개변수 : 이름을 지역변수 이름과 동일하게 작성하면 오류가 발생했었는데... 지금은 ㄱㅊ
        let을 사용할 필요가 없다. 타입도 없고 그냥 이름만 쓰면 됨.</li>
        <li>함수를 선언하면 코드를 실행하기 전에 인터프리터 엔진(V8엔진)이 타입인 줄 알고 미리 프로토타입을 만든다.
        호이스팅 현상이 발생하는 원인...!</li>
    </ul>

    <h2>함수의 선언법 2</h2>
    <ul>
        <li>const 이름 = function(a,b){return 반환값;} : 이름이 없는 함수를 변수 or 상수가 참조 </li>
        <li>인터프리터 엔진이 함수를 찾지 못해서 미리 프로토 타입을 만들지 않는다.(해당 코드가 실행될 때 까지 함수는 미리 만들어지지않는다)</li>
        <li>의문 => 함수가 나중에 선언 됐는데 왜 그 앞에서도 호출이 되는가?? -> 오류를 막으려고 등장한 방식</li>
        <li>또한 함수 선언이 너무 많으면 js실행이 너무 느려져서 우선 실행하면서 함수가 선언되게 하기 위해 사용함</li>
    </ul>

    <h2>함수의 선언법 3</h2>
    <ul>
        <li>const 함수이름 = ()=>{return 반환값;} : 화살표 함수를 변수 or 상수가 참조</li>
        <li>()=>{} : 함수를 항상 타입으로 인지하는 JS의 단점을 극복하기 위해 오로지 실행만을 하기 위한 함수를 도입(es6)</li>
        <li>모든 함수에 타입을 부여한다면 메모리를 많이 사용하기에... 실행에만 사용될 함수 개념이 필요</li>
        <li>함수와 필드 바인딩 문제로 화살표 함수가 등장!!(나중에 따로 배움)</li>
        <li></li>
    </ul>

<script>
  /*
  java에서는

  class Calc{
    int sum(int a, int b)
    return a+b
  }

   */
  //JS의 함수 규칙
  //타입을 안씀
  const sum2 = function(){ //이름이 없는 함수를 바로 변수에 참조시키는법(선언하고나서만 사용가능)
    //호이스팅 현상을 막기위해, 메모리를 아끼기 위해..
    return a+b;
  }

  const sum3=(a,b) => { //js의 화살표함수
      //js의 화살표함수는 프로토타입이 없는 일반함수. 타입이 될 수 없는 순수한 실행용 함수다
      return a+b;
  }

  function sum(a,b){ //함수를 정의하면서 이름을 짓는 법(어디서든 사용가능 = 함수의 hoisting 현상)
      //함수는 프로토타입이기 때문에 v8엔진이 함수만 찾아서 메모리에 생성 후 저장한다
    return a+b;
  }

  console.log(`sum(10,11)=${sum(10,11)}`)
  function Calc(){
    this.sum=function(a,b){ //this 필드접근자 : 해당 타입이 객체로 만들어졌을때 필드에 접근함
      //단순히 Calc의 function에 접근하는개념이 아니다...
      return a+b;
    }
  }

  //Calc.sum()으로 10+11의 결과를 출력하세요
  console.log(new Calc().sum(10,11))
  const calc = new Calc();
  console.log(calc.sum(10,11))


</script>
</body>
</html>